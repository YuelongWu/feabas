meshing:
    num_workers: 15
    mesh_size: 600  # spacings between mesh grids in pixel at mip0
    simplify_tol: 2 # when approximate regions defined by mask images to polygon, the tolerance of distance error
    mask_dir: null  # the folder contains the material masks. if set to null, default to working_directory/align/material_masks. If mask not exist in this folder, use the one in the thumbnail folder     
    mask_mip_level: 4 # the resolution of the masks in mask_dir folder
    area_thresh: 25 # regions with area smaller than the threshold will be discarded

matching:
    working_mip_level: 2  # resolution at which to do the matchin
    loader_config:
        cache_size: 60  # total number of source images allowed to cache in RAM
    matcher_config:
        num_workers: 15
        batch_size: 100 # number of cropped regions to do fft at the same time
        conf_thresh: 0.35    # cross-correlations with confidence value smaller than this will be rejected
        sigma: 3.5  # sigma of DoG filter applied to image before matching
        geodesic_mask: false # whether to mask out image subregions with large geodesic distance from the center of the patches to match
        pad: true   # whether to double the fft points. more compute but useful when initial placements is off
        distributor: cartesian_region   # cartesian_region/intersect_triangulation
        spacings: [400, 100]    # distance between grid points at each coarse-to-fine level
        shrink_factor: 0.7  # the size of the cropped fft tiles compared to the spacings
        residue_mode: threshold # huber or threshold or None, deciding how to damp matches with large residue errors after optimization
        residue_len: 3  # characteristic residue distance used for damping. use 0 to skip
        min_boundary_distance: 20   # minimum distance allowed from a matching point to the boundary of the meshes
        stiffness_multiplier_threshold: 0.5 # material with stiffness multiplier smaller than this will not be considered during the matching process
        render_weight_threshold: 0.1  # material with render weight smaller than this will not be rendered during the matching process

optimization:
    stack_config:
        mip_level: 0    # all the matching points and meshes are scaled to this mip level before optimization
        mesh_cache_size: 90 # number of meshes to cache in RAM. should be larger than window_size + buffer_size
    slide_window:
        num_workers: 2
        start_loc: M    # starting location of the optimization. L: left, R: right, M: start from middle and move in both directions
        window_size: 64 # the width of the sliding window
        buffer_size: 16 # the number of overlapping sections to re-optimize when window is moved, to minimize potential fringe effects.
        residue_mode: huber
        residue_len: 20 # matching points with error larger than this width will be weakened in the second round of mesh relaxation
        elastic_params:
            tol: 1.0e-7 # convergence tolerance for the solver
            atol: 0.001
            continue_on_flip: true # if to continue the process when a flipped triangle is detected. otherwise stop the program and raise error
            batch_num_matches: null # larger numberneeds more RAM but faster. default to (total # of matches)/10
            callback_settings:
                timeout: null   # maximum time (in second) allowed for each round of optimization. After the timeout, select the best solution so far
                early_stop_thresh: null # if after each step, the maximum movement of the mesh points is smaller than this, consider it a insiginificant update
                chances: null   # number of insignificant or diverge steps allowed before an early stop envoked
                eval_step: 10   # the interval (in steps) when the significance of the updates is evaluated 

rendering:
    num_workers: 15
    offset_bbox: true   # if set to true, before the first rendering session, all the transformations will be normalized to align the most upper-left corner of the stack to (0,0)
    out_dir: null  # directory to save the aligned stack. if set to null, default to working_directory/aligned_stack
    prefix_z_number: true   # whether to add the z-index before the section_name when rendering
    pattern: _tr{ROW_IND}-tc{COL_IND}.png  # pattern of the filenames
    one_based: true # zero-based or one-based row/colume indexing
    max_tile_per_job: 20
    mip_level: 0
    canvas_bbox: null   # if defined, only render the image inside the canvas box. otherwise render the whole thing.
    tile_size: [4096, 4096]
    remap_interp: LANCZOS # LANCZOS | CUBIC | LINEAR | NEAREST
    loader_config:
        cache_size: 50
        fillval: 0
        apply_CLAHE: false  # should already be applied during stitching 

downsample:
    num_workers: 15
    parallel_within_section: true   # whether to parallel among tiles within a section, or among sections
    max_mip: 7
    format: jpg


tensorstore_rendering: # render to tensorstore volume
    num_workers: 15
    mip_level: 0
    z_min: 0    # minimum z index of the volume. value other than 0 seems to cause error for some reason...
    z_max: null # maximum z index (exclusive) of the volume. If set to null, count the section number.
    driver: neuroglancer_precomputed
    outdir: null # directory to save the aligned stack. if set to null, default to working_directory/aligned_tensorstore
    chunk_shape: [1024, 1024, 16]
    read_chunk_shape: [128, 128, 16]
    canvas_bbox: null   # if set to null, use the extremes of all the meshes to determine: may be problematic if the transformations are changed between different rendering rounds
    max_tile_per_job: 320
    remap_interp: LANCZOS # LANCZOS | CUBIC | LINEAR | NEAREST
    loader_config:
        cache_size: 0
        fillval: 0
        apply_CLAHE: false  # should already be applied during stitching 